{% extends "base.html" %}

{% block head %}

<head>
    {% block title %}Queue{% endblock %}
    {% block extra_css %}
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/queue.css') }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">

    {% endblock %}
</head>
{% endblock %}

{% block content %}

<body>
	    <div class="main-container">
	        <h1 class="text-head">Job Queue</h1>
	        <div class="queue-toolbar">
	            <div class="queue-filters">
	                <div class="queue-filter">
	                    <label for="jobIdSearchInput" class="queue-label">Job ID</label>
	                    <input id="jobIdSearchInput" class="select-custom" type="text" placeholder="e.g. 2f7c..." autocomplete="off" />
	                </div>
	                <div class="queue-filter">
	                    <label for="statusFilterSelect" class="queue-label">Job Status</label>
	                    <select id="statusFilterSelect" class="select-custom">
	                        <option value="">All</option>
	                    </select>
	                </div>
	                <div class="queue-filter">
	                    <label for="dateFromInput" class="queue-label">Submitted From</label>
	                    <input id="dateFromInput" class="select-custom" type="date" />
	                </div>
	                <div class="queue-filter">
	                    <label for="dateToInput" class="queue-label">Submitted To</label>
	                    <input id="dateToInput" class="select-custom" type="date" />
	                </div>
	                <div class="queue-actions">
	                    <button id="jobFiltersApplyBtn" type="button" class="text-head rounded-button">Filter</button>
	                    <button id="jobFiltersClearBtn" type="button" class="text-head rounded-button">Clear</button>
	                </div>
	            </div>
	        </div>
	        <table id="queueTable">
            <thead>
                <tr>
                    <th>Job ID</th>
                    <th>Job Status</th>
                    <th>Result Details</th>
                    <th>Submitted Date</th>
                </tr>
            </thead>
            <tbody>
                <!-- Jobs will be listed here -->
            </tbody>
        </table>
        <div id="pagination">
            <button onclick="goToFirstPage()" class="text-head rounded-button">First Page</button>
            <button onclick="previousPage()" class="text-head rounded-button">Previous</button>
            <span class="text-head">Page <span id="page_number" class="text-head">1</span> of <span id="total_pages"
                    class="text-head">1</span></span>
            <button onclick="nextPage()" class="text-head rounded-button">Next</button>
            <button onclick="goToLastPage()" class="text-head rounded-button">Last Page</button>
            <span class="text-head" style="margin-left: 20px;">Items per page</span>
            <select id="recordsPerPageSelect" class="select-custom"
                style="margin: 0 5px; min-width: 80px; height: 38px; font-size: 1em;">
                <option value="5">5</option>
                <option value="10" selected>10</option>
                <option value="20">20</option>
                <option value="50">50</option>
            </select>
            <span class="text-head" style="margin-left: 20px;">Jump to</span>
            <input id="jumpToPageInput" class="select-custom" type="number" min="1"
                style="width: 70px; height: 38px; font-size: 1em; display: inline-block;" />
            <button onclick="jumpToPage()" class="text-head rounded-button" style="margin-left: 5px;">Go</button>
        </div>
    </div>
    <!-- Modal -->
    <div id="privateKeyModal" class="mymodal" style="display: none;">
        <div class="modal-content">

            <div class="modal-header">
                <h2 style="font-family: 'Poetsen One', sans-serif;">Upload Private Key</h2>
                <span class="close">&times;</span>

            </div>
            <a class="mymodal-text-title">Job ID:</a>
            <a id="taskIdShow" class="mymodal-text"></a>

            <form id="privateKeyForm">

                <button type="button" id="uploadBtn" class="mymodal-button">Choose File</button>
                <input type="file" id="privateKeyFile" required style="display: none;">

                <button type="submit" class="mymodal-button">Upload</button>
            </form>
        </div>
    </div>


</body>
{% endblock %}

{% block scripts %}
<script>
	    let current_page = 1;
	    let records_per_page = 10;
	    let fullJobData = [];
	    let filteredJobData = [];
	    let jobIdQuery = "";
	    let statusQuery = "";
	    let dateFromQuery = "";
	    let dateToQuery = "";
	    let refreshTimer = null;

    window.onload = function () {
        listJobs(); // 初始加载
    };

	    function parseSubmittedDate(dateStr) {
	        if (!dateStr) return null;
	        const direct = new Date(dateStr);
	        if (!isNaN(direct.getTime())) return direct;
	        const normalized = new Date(String(dateStr).replace(' ', 'T'));
	        if (!isNaN(normalized.getTime())) return normalized;
	        return null;
	    }

	    function populateStatusOptions() {
	        const select = document.getElementById('statusFilterSelect');
	        if (!select) return;
	
	        const existingValue = select.value || "";
	        const uniqueStatuses = Array.from(new Set(fullJobData.map(j => j.status).filter(Boolean)));
	        const preferredOrder = ['Submitted', 'SUCCESS', 'FAILED', 'Timeout'];
	
	        uniqueStatuses.sort((a, b) => {
	            const ia = preferredOrder.indexOf(a);
	            const ib = preferredOrder.indexOf(b);
	            if (ia === -1 && ib === -1) return String(a).localeCompare(String(b));
	            if (ia === -1) return 1;
	            if (ib === -1) return -1;
	            return ia - ib;
	        });
	
	        select.innerHTML = '<option value="">All</option>';
	        uniqueStatuses.forEach(s => {
	            const opt = document.createElement('option');
	            opt.value = s;
	            opt.textContent = s;
	            select.appendChild(opt);
	        });
	
	        select.value = uniqueStatuses.includes(existingValue) ? existingValue : "";
	    }

	    function listJobs() {
	        fetch('/retroplanner/jobs')
	            .then(response => response.json())
	            .then(data => {
	                fullJobData = data.map(job => ({
	                    job_id: job[0],
	                    status: job[1],
	                    result: job[2],
	                    date: job[3],
	                }));
	                populateStatusOptions();
	                applyFilterAndRender(true);
	            });

        if (refreshTimer) clearTimeout(refreshTimer);
        refreshTimer = setTimeout(listJobs, 60000);
    }

	    function applyFilterAndRender(resetPage) {
	        const idQ = (jobIdQuery || '').trim().toLowerCase();
	        const statusQ = (statusQuery || '').trim();
	        const fromQ = (dateFromQuery || '').trim();
	        const toQ = (dateToQuery || '').trim();
	
	        const fromDate = fromQ ? new Date(`${fromQ}T00:00:00`) : null;
	        const toDate = toQ ? new Date(`${toQ}T23:59:59`) : null;
	
	        filteredJobData = fullJobData.filter(j => {
	            if (idQ && !(String(j.job_id || '').toLowerCase().includes(idQ))) return false;
	            if (statusQ && String(j.status || '') !== statusQ) return false;
	            if (fromDate || toDate) {
	                const submitted = parseSubmittedDate(j.date);
	                if (!submitted) return false;
	                if (fromDate && submitted < fromDate) return false;
	                if (toDate && submitted > toDate) return false;
	            }
	            return true;
	        });
	        if (resetPage) current_page = 1;
	        changePage(current_page);
	    }

    function changePage(page) {
        const total_pages = Math.max(1, Math.ceil(filteredJobData.length / records_per_page));
        if (page < 1) page = 1;
        if (page > total_pages) page = total_pages;
        current_page = page;

        const tbody = document.querySelector("#queueTable tbody");
        tbody.innerHTML = '';

        if (filteredJobData.length === 0) {
            const row = document.createElement('tr');
            const cell = document.createElement('td');
            cell.colSpan = 4;
            cell.className = 'queue-empty';
            cell.textContent = jobIdQuery ? 'No jobs found for this Job ID.' : 'No jobs found.';
            row.appendChild(cell);
            tbody.appendChild(row);
            updatePaginationButtons();
            return;
        }

        const start = (page - 1) * records_per_page;
        const end = Math.min(start + records_per_page, filteredJobData.length);

	        for (let i = start; i < end; i++) {
	            const job = filteredJobData[i];
	            const row = document.createElement('tr');

	            const cell1 = document.createElement('td');
	            const cell2 = document.createElement('td');
	            const cell3 = document.createElement('td');
	            const cell4 = document.createElement('td');

	            cell1.textContent = job.job_id;
	            cell2.textContent = job.status;
	            if (job.status === 'Timeout' && typeof job.result === 'string' && job.result.startsWith('TOO_LARGE_LOCAL')) {
	                cell2.title = 'Workload too large; please run locally.';
	            }

	            if (job.status === 'SUCCESS') {
	                const link = document.createElement('a');
	                link.href = '#';
	                link.textContent = job.result;
                link.className = 'rounded-button';
                link.addEventListener("click", function () {
                    openModal(job.job_id);
                });
                cell3.appendChild(link);
	            } else if (job.status === 'Submitted') {
	                const img = document.createElement('img');
	                img.src = '/retroplanner/static/gif/icons8-waiting.gif';
	                img.alt = 'Waiting...';
	                cell3.appendChild(img);
	            } else if (job.status === 'Timeout' && typeof job.result === 'string' && job.result.startsWith('TOO_LARGE_LOCAL')) {
	                cell3.textContent = '—';
	            } else {
	                cell3.textContent = job.result;
	            }

            cell4.textContent = job.date;

            row.appendChild(cell1);
            row.appendChild(cell2);
            row.appendChild(cell3);
            row.appendChild(cell4);
            tbody.appendChild(row);
        }

        updatePaginationButtons();
    }

    function updatePaginationButtons() {
        const total_pages = Math.max(1, Math.ceil(filteredJobData.length / records_per_page));
        document.getElementById("page_number").innerText = current_page;
        document.getElementById("total_pages").innerText = total_pages;
    }

    function nextPage() {
        if (current_page < Math.ceil(filteredJobData.length / records_per_page)) {
            current_page++;
            changePage(current_page);
        }
    }

    function previousPage() {
        if (current_page > 1) {
            current_page--;
            changePage(current_page);
        }
    }

    function goToFirstPage() {
        changePage(1);
    }

    function goToLastPage() {
        const total_pages = Math.max(1, Math.ceil(filteredJobData.length / records_per_page));
        changePage(total_pages);
    }

    function jumpToPage() {
        const input = document.getElementById('jumpToPageInput');
        const page = parseInt(input.value);
        const total_pages = Math.max(1, Math.ceil(filteredJobData.length / records_per_page));
        if (!isNaN(page) && page >= 1 && page <= total_pages) {
            changePage(page);
        } else {
            input.value = '';
            input.placeholder = 'Invalid';
        }
    }

    function openModal(jobId) {
        console.log("Opening modal for job:", jobId);
        const modal = document.getElementById('privateKeyModal');
        modal.style.display = 'block';
        document.getElementById('taskIdShow').innerText = jobId;

        document.getElementById('privateKeyForm').onsubmit = function (event) {
            event.preventDefault();
            const formData = new FormData();
            const fileInput = document.getElementById('privateKeyFile');
            if (!fileInput.files.length) {
                alert("Please choose a .pem private key file.");
                return;
            }
            formData.append('privateKey', fileInput.files[0]);
            formData.append('jobId', jobId);

            fetch('/retroplanner/validate-key', {
                method: 'POST',
                body: formData
            })
                .then(async response => {
                    if (!response.ok) {
                        const text = await response.text();
                        console.error('Server Error:', text);
                        alert('Server error: unable to validate key.');
                        modal.style.display = 'none';
                        return;
                    }
                    return response.json();
                })
                .then(data => {
                    if (!data) return;
                    if (data.success) {
                        window.location.href = '/retroplanner/locked_results/' + jobId + '&resultsLimit-50';
                    } else {
                        alert('Invalid private key');
                        modal.style.display = 'none';
                    }
                });
        };
    }

	    // ✅ 页面加载后全局只绑定一次（modal 和下拉选择事件）
	    document.addEventListener('DOMContentLoaded', function () {
	        const jobIdSearchInput = document.getElementById('jobIdSearchInput');
	        const statusFilterSelect = document.getElementById('statusFilterSelect');
	        const dateFromInput = document.getElementById('dateFromInput');
	        const dateToInput = document.getElementById('dateToInput');
	        const applyBtn = document.getElementById('jobFiltersApplyBtn');
	        const clearBtn = document.getElementById('jobFiltersClearBtn');
	
	        const syncFiltersFromUI = () => {
	            jobIdQuery = (jobIdSearchInput?.value || '').trim();
	            statusQuery = (statusFilterSelect?.value || '').trim();
	            dateFromQuery = (dateFromInput?.value || '').trim();
	            dateToQuery = (dateToInput?.value || '').trim();
	        };
	
	        const applyFilters = () => {
	            syncFiltersFromUI();
	            applyFilterAndRender(true);
	        };
	
	        const clearFilters = () => {
	            if (jobIdSearchInput) jobIdSearchInput.value = '';
	            if (statusFilterSelect) statusFilterSelect.value = '';
	            if (dateFromInput) dateFromInput.value = '';
	            if (dateToInput) dateToInput.value = '';
	            jobIdQuery = '';
	            statusQuery = '';
	            dateFromQuery = '';
	            dateToQuery = '';
	            applyFilterAndRender(true);
	        };
	
	        applyBtn.addEventListener('click', applyFilters);
	        clearBtn.addEventListener('click', clearFilters);
	
	        jobIdSearchInput.addEventListener('keydown', function (e) {
	            if (e.key === 'Enter') applyFilters();
	        });
	        statusFilterSelect.addEventListener('change', applyFilters);
	        dateFromInput.addEventListener('change', applyFilters);
	        dateToInput.addEventListener('change', applyFilters);

	        // Make the whole date input open the picker (where supported)
	        [dateFromInput, dateToInput].forEach((el) => {
	            if (!el) return;
	            el.addEventListener('click', () => {
	                if (typeof el.showPicker === 'function') el.showPicker();
	                else el.focus();
	            });
	        });

	        document.getElementById('uploadBtn').addEventListener('click', function () {
	            document.getElementById('privateKeyFile').click();
	        });

        document.getElementById('privateKeyFile').addEventListener('change', function () {
            const file = this.files[0];
            document.getElementById('uploadBtn').textContent = file ? file.name : 'Choose File';
        });

        document.querySelector('.close').onclick = function () {
            document.getElementById('privateKeyModal').style.display = 'none';
        };

        window.onclick = function (event) {
            const modal = document.getElementById('privateKeyModal');
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        };

        document.getElementById('recordsPerPageSelect').addEventListener('change', function () {
            records_per_page = parseInt(this.value);
            current_page = 1;
            changePage(current_page);
        });
    });
</script>
{% endblock %}
